#!/usr/bin/python
# coding=utf-8
#
# Copyright (C) 2015 Allis Tauri <allista@gmail.com>
# 
# degen_primer is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# degen_primer is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along
# with this program.  If not, see <http://www.gnu.org/licenses/>.
'''
Created on Dec 7, 2015

@author: Allis Tauri <allista@gmail.com>
'''

import sys, os, time, argparse
import multiprocessing
from collections import OrderedDict

from Bio.KEGG import REST
from Bio.KEGG import Enzyme
from Bio.Alphabet import IUPAC
from Bio.Seq import Seq
from Bio.SeqRecord import SeqRecord
from Bio import SeqIO
from Bio.Align.Applications import MuscleCommandline, MafftCommandline

RETRIES = 3
PAUSE = 5

isatty = hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()
ncpu = multiprocessing.cpu_count()

def KEGG_cmd(cmd, args, outfile, emsg, force=False):
    if not force and os.path.isfile(outfile): return True
    for _try in xrange(RETRIES):
        try: 
            request = cmd(args)
            with open(outfile, 'w') as out:
                out.write(request.read())
            return True
        except Exception, ex:
            print ex
            if _try < RETRIES-1: time.sleep(PAUSE)
            else: print emsg 
    return False
    

class kgene(object):
    '''Represents KEGG's gene database entry in the form organism:gen_id'''
    def __init__(self, org, gid):
        self.org = org
        self.id  = gid
        self.request = "%s:%s" % (self.org, self.id) 
        self.filename = "%s-%s.kegg" % (self.org, self.id) 
    
    def __str__(self): return self.request
#end class

class Lineage(list):
    '''Handles lineage information'''
    def __init__(self, line):
        line = line.strip('\n\r')
        self.extend(line.split(';'))
        self.str = ':'.join(self).lower() 
        
    def includes(self, other):
        return other.str.startswith(self.str)
    
    def __str__(self): return self.str
#end class

class Organism(object):
    '''Holds a KEGG's organism record as returned by /list/organism REST command'''
    def __init__(self, line=None):
        self.T = ""
        self.org = ""
        self.description = ""
        self.lineage = None
        if line is not None: self.parse(line)
        
    def __str__(self):
        return '%s: %s [%s]' % (self.org, self.description, self.lineage)
    
    def parse(self, line):
        fields = line.split('\t')
        if len(fields) < 4:
            raise ValueError("Organism line should have three fields divided by tabs")
        self.T = fields[0]
        self.org = fields[1]
        self.description = fields[2]
        self.lineage = Lineage(fields[3])
        
    def belongs2(self, lineage):
        return lineage.includes(self.lineage)
#end class

class Organisms(dict):
    '''Representation and parser for KEGG's organism list'''
    def __init__(self, filename=None):
        dict.__init__(self)
        self.parse(filename)
        
    def parse(self, filename):
        if not filename or not os.path.isfile(filename): return False
        with open(filename) as inp:
            for line in inp:
                try: org = Organism(line)
                except ValueError, er:
                    print 'Unable to parse organism info: %s' % line
                    print er
                    continue
                self[org.org] = org
                if org.description: self[org.description] = org
        return True
#end class

class KEGGRecord(dict):
    '''Generic representation of the the KEGG file format'''
    def __init__(self):
        dict.__init__(self)
        self.entry = ""
        self.description = ""
        
    def __str__(self):
        return 'ENTRY: %s\t%s\n%s' % (self.entry, self.description, dict.__str__(self))
    
    @classmethod
    def parse(cls, filename):
        if not filename or not os.path.isfile(filename): return
        with open(filename) as inp:
            record = cls()
            keyword = ""
            for line in inp:
                if line[:3] == '///':
                    yield record
                    record = cls()
                    continue
                if line[:12] != "            ":
                    keyword = line[:12].strip()
                data = line[12:].strip()
                if keyword == "ENTRY":
                    words = data.split()
                    record.entry = words[1]
                    record.description = " ".join(words[1:])
                field = record.get(keyword, None)
                if field is None:
                    field = []
                    record[keyword] = field
                field.append(data)
#end class

class FamilyFetcher(object):

    organisms = Organisms()
    orgfile = 'organisms.kegg'
    
    def __init__(self, proj, ec, lineage):
        self.proj = proj
        self.ec = ec
        self.lineage = Lineage(lineage)

        self.recfile = '%s-EC_%s.kegg' % (self.proj, self.ec)
        self.genesdir = '%s-EC_%s-GENES' % (self.proj, self.ec)
        self.ialnfile = '%s-EC_%s-ialn.faa' % (self.proj, self.ec)
        self.oalnfile = '%s-EC_%s-aln.faa' % (self.proj, self.ec)
        
    @classmethod
    def get_organisms(cls, force = False):
        if not force and len(cls.organisms) > 0: return True
        if not KEGG_cmd(REST.kegg_list, 'organism', 
                    cls.orgfile, 'Unable to get the list of KEGG organisms', force=force):
            return False
        cls.organisms = Organisms(cls.orgfile)
        return True
    
    @classmethod
    def clade_phylogeny(cls, clade):
        with open(clade) as inp:
            for line in inp:
                if not line: continue
                words = line.split()
                desc = " ".join(words[1:])
                org = cls.organisms.get(desc)
                if org: print org.lineage[1:3], org.description
    
    def get_data(self, force = False):
        #make a directory to store gene files
        try: os.mkdir(self.genesdir)
        except OSError: pass
        #fetch a record for the needed enzyme
        if not KEGG_cmd(REST.kegg_get, 'ec:'+self.ec, 
                        self.recfile, 'Unable to get record for EC: %s' % self.ec):
            return False
        #parse the record
        records = Enzyme.parse(open(self.recfile))
        genes = [kgene(gr[0].lower(), g) for r in records for gr in r.genes for g in gr[1]]
        #analyze genes
        alignment = OrderedDict()
        numgenes = len(genes)
        os.chdir(self.genesdir)
        for i, gene in enumerate(genes):
            progress = float(i+1)/numgenes*100.0
            print 'Checking source organism  [%3.0f%%]: %s' % (progress, gene.org)
            org = self.organisms.get(gene.org)
            if org is None:
                print 'No such organism in the DB: %s\n' % gene.org
                print 'Try to run with -f option to update the list of organisms.'
                continue
            if not org.belongs2(self.lineage):
                print 'Organism "%s (%s)"\nis filtered by lineage "%s"\n' % (gene.org, org.lineage, self.lineage)
                continue
            sys.stdout.flush()
            if not os.path.isfile(gene.filename):
                print 'Fetching gene information [%3.0f%%]: %s' % (progress, gene)
                KEGG_cmd(REST.kegg_get, gene, gene.filename, 
                         'Unable to get record for gene: %s' % gene, force)
            print 'Parsing gene information  [%3.0f%%]: %s' % (progress, gene.id)
            for gr in KEGGRecord.parse(gene.filename):
                plines = gr.get('AASEQ')[1:]
                if not plines:
                    print 'No AASEQ field in %s record' % gr.entry
                    continue
                sseq = ''.join(plines)
                shash = hash(sseq)
                if shash in alignment:
                    print '%s sequence is the exact same as %s' % (gene.id, alignment[shash].id)
                    alignment[shash].description += ', '+org.description
                else: 
                    alignment[shash] = SeqRecord(Seq(sseq, IUPAC.IUPACProtein), gene.id, 
                                                 description=org.description)
            print
        #write initial alignment
        os.chdir('..')
        with open(self.ialnfile, 'w') as out:
            SeqIO.write(alignment.values(), out, 'fasta')
            
    aligners = ('mafft', 'muscle')
    
    def align_data(self, method=None):
        print 'Aligning amino acid sequences...'
        if os.path.isfile(self.oalnfile):
            print 'The alignment is already exists'
            if isatty:
                inp = raw_input('Are you sure you want to re-run the the alignment tool? [y/n]: ')
                if inp.lower() != 'y': return
            else:
                print 'To re-run the alignment tool, remove/rename the "%s" file and try again' % self.oalnfile
                return
        print 'This may take quite a while...'
        if method == 'muscle':
            cline = MuscleCommandline(input=self.ialnfile, out=self.oalnfile)
            print cline
            stdout, stderr = cline()
            print stdout
        else: #default
            cline = MafftCommandline(thread=ncpu, auto=True, input=self.ialnfile)
            stdout, stderr = cline()
            with open(self.oalnfile, 'wb') as out:
                out.write(stdout)
        if stderr: sys.stderr.write(stderr)
        print 'Done'
        

if __name__ == '__main__':
#    N2O_proj = FamilyFetcher('N2O_RedOx', '1.7.2.4', 'Prokaryotes')
#    COX_proj = FamilyFetcher('COX', '1.2.99.2', 'Prokaryotes')
    
    #parse command line
    parser = argparse.ArgumentParser(description='Fetches all protein sequences '
                                     'for a given EC number from KEGG database, '
                                     'filters them according to given lineage '
                                     'and aligns them using MUSCLE.')
    parser.add_argument('project', metavar='project_name',
                        type=str, nargs=1,
                        help='Name of the project')
    parser.add_argument('EC', metavar='EC_number',
                        type=str, nargs=1,
                        help='EC number of the enzyme to analyze')
    parser.add_argument('-l', '--lineage', metavar='"Phylum;Class;..."', default=None,
                        type=str, nargs=1,
                        help='Lineage of interest given as string with clades '
                        '(from top to bottom) separated by semicolon')
    parser.add_argument('-f', '--force', action='store_true',
                        help='Forces fetching of all the data from the KEGG.')
    parser.add_argument('-a', '--aligner', metavar=FamilyFetcher.aligners[0],
                        type=str, nargs=1,
                        help='Align obtained sequences using selected method. '
                        'Supported are: %s' % ' '.join(FamilyFetcher.aligners))
    args = parser.parse_args()
    
    lineage = args.lineage[0] if args.lineage else ''
    proj = FamilyFetcher(args.project[0], args.EC[0], lineage)
    FamilyFetcher.get_organisms(force=True)
    proj.get_data(force=args.force)
    if args.aligner: proj.align_data(args.aligner)